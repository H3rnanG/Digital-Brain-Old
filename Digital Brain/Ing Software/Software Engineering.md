#EngineeringSoftware 

# Conceptos
## Que es la ingenieria de software?
**La [[Diccionary#Ingenieria|Ingeniería]] de [[Diccionary#Software|Software]] es una [[Diccionary#Disciplina|disciplina]] de la ingeniería que se enfoca en el diseño, desarrollo, mantenimiento y evaluación de sistemas de software.** Esta disciplina aplica principios de la ingeniería y las ciencias de la computación para crear software de alta calidad y confiabilidad.
El objetivo principal de la ingeniería de software es desarrollar software de manera sistemática y eficiente, utilizando un enfoque disciplinado y controlado para el proceso de desarrollo de software. Esto incluye la identificación de requerimientos, el diseño de la arquitectura del software, la codificación, las pruebas, el mantenimiento y la documentación.

Para entender mejor se recomienda saber ciertos conceptos que te los dejo a continuacion: [[Programming Concepts]]

---
## Que ramas o subdisciplinas existe en la ingenieria de software?

1.  **Ingeniería de requisitos:** Se enfoca en la captura, análisis y especificación de los requisitos del software, para asegurar que el software cumpla con las necesidades y expectativas del usuario y/o cliente.
2.  **Diseño de software:** Se enfoca en la creación de una arquitectura y diseño de alto nivel para el software, incluyendo decisiones sobre la estructura del software, la interacción entre los diferentes componentes del sistema, y la selección de tecnologías apropiadas.
3.  **Desarrollo de software:** Se enfoca en la implementación del software, incluyendo la codificación, prueba y documentación del mismo.
4.  **Gestión de proyectos de software:** Se enfoca en la planificación, seguimiento y control de los proyectos de software, asegurando que se cumplan los objetivos del proyecto en términos de plazos, presupuesto y calidad.
5.  **Calidad de software:** Se enfoca en la evaluación y mejora de la calidad del software, incluyendo pruebas, revisiones, métricas y estándares.
6.  **Mantenimiento y evolución de software:** Se enfoca en el mantenimiento y mejora del software después de su implementación, incluyendo corrección de errores, actualización de funcionalidades y adaptación a nuevos requisitos.
Estas son solo algunas de las subdisciplinas de la Ingeniería de Software, y existen muchas otras áreas en las que los ingenieros de software pueden especializarse, como la seguridad de software, la inteligencia artificial, la computación en la nube, entre otras.
---
## Division del trabajo
##### [[Front End]]
Es parte del software que se encarga de la lógica de negocio, la gestión de datos y la comunicación con otras aplicaciones y sistemas. En otras palabras, el back-end es el "motor" del software, que se ejecuta en el servidor y se encarga de procesar las solicitudes del usuario y proporcionar las respuestas correspondientes.

Algunas de las tareas que se realizan en el back-end son:
-   Manejo de bases de datos: se encarga de almacenar, recuperar y manipular los datos que se utilizan en el software.
-   Procesamiento de solicitudes: recibe las solicitudes del usuario, las procesa y genera las respuestas correspondientes.
-   Seguridad: gestiona la seguridad del sistema y se encarga de proteger la información confidencial de los usuarios.
-   Integración con otros sistemas: se comunica con otros sistemas y servicios para intercambiar información y datos.
-   Optimización de rendimiento: se asegura de que el software se ejecute de manera eficiente y que responda rápidamente a las solicitudes de los usuarios.
##### [[Back End]]
Es parte del software que se encarga de la lógica de negocio, la gestión de datos y la comunicación con otras aplicaciones y sistemas. En otras palabras, el back-end es el "motor" del software, que se ejecuta en el servidor y se encarga de procesar las solicitudes del usuario y proporcionar las respuestas correspondientes.

Algunas de las tareas que se realizan en el back-end son:
-   Manejo de bases de datos: se encarga de almacenar, recuperar y manipular los datos que se utilizan en el software.
-   Procesamiento de solicitudes: recibe las solicitudes del usuario, las procesa y genera las respuestas correspondientes.
-   Seguridad: gestiona la seguridad del sistema y se encarga de proteger la información confidencial de los usuarios.
-   Integración con otros sistemas: se comunica con otros sistemas y servicios para intercambiar información y datos.
-   Optimización de rendimiento: se asegura de que el software se ejecute de manera eficiente y que responda rápidamente a las solicitudes de los usuarios.
---
## Matematicas para ingenieria de software
Como programador backend, hay algunas áreas de las matemáticas que son especialmente relevantes para tu trabajo. Estas son algunas de las más importantes:
1. *Álgebra:* El álgebra es fundamental para comprender y manipular expresiones matemáticas, trabajar con variables y resolver ecuaciones. Esto es esencial en la programación para realizar cálculos y operaciones con datos.
    
2.  *Lógica:* La lógica es crucial para el desarrollo de algoritmos y la resolución de problemas complejos. Te ayudará a razonar de manera estructurada y a crear flujos lógicos para implementar soluciones eficientes.
    
3.  *Teoría de conjuntos:* La teoría de conjuntos es útil para comprender cómo trabajar con colecciones de datos y manipular conjuntos en programación. Te permitirá utilizar operaciones como la unión, intersección y diferencia de conjuntos.
    
4.  *Cálculo:* Aunque no siempre es estrictamente necesario, tener una comprensión básica de cálculo diferencial e integral puede ser útil en programación, especialmente si trabajas en áreas como procesamiento de señales, aprendizaje automático (machine learning) o gráficos computacionales.
    
5.  *Probabilidad y estadística:* La probabilidad y estadística son importantes en muchos aspectos de la programación, como el análisis de datos, la toma de decisiones y la optimización de algoritmos. Te ayudarán a comprender conceptos como la distribución de datos, los promedios, la desviación estándar y la inferencia estadística.
  ##
---
# Anisis de la ingenieria de software
## Ciclo de vida de un software

**El ciclo de vida del desarrollo del software** (también conocido como SDLC o _Systems Development Life Cycle_) contempla las fases necesarias para validar el **desarrollo del software** y así garantizar que este cumpla los requisitos para la aplicación y verificación de los procedimientos de desarrollo, asegurándose de que los métodos usados son apropiados.

Su origen radica en que es muy costoso rectificar los posibles errores que se detectan tarde en la fase de implementación. Utilizando metodologías apropiadas, se podría detectar a tiempo para que los programadores puedan centrarse en la calidad del software, cumpliendo los plazos y los costes asociados.
### Metodologias de un proyecto de software
Una metodología para la gestión de proyectos es una serie de principios, herramientas y técnicas que se aplican para planificar, desarrollar, implementar y gestionar proyectos.  Hoy en día hay varias metodologías, marcos y modelos, o incluso mezclas de varias.
### Metodologias Tradicionales:
#### [[Cascada(Waterfall)]]
Es uno de los enfoques más antiguos y lineales en el desarrollo de software. Se divide en etapas secuenciales, como requerimientos, diseño, implementación, pruebas y mantenimiento. Cada fase debe completarse antes de pasar a la siguiente, lo que hace que sea difícil incorporar cambios en etapas posteriores.
#### Modelo en V
Es una variante del modelo en cascada que enfatiza la relación entre cada fase de desarrollo y su correspondiente fase de prueba. Cada fase de desarrollo se asocia con una fase de prueba específica para garantizar que se cumplan los requisitos y se realicen pruebas adecuadas.
#### Modelo en Espiral
Es un enfoque iterativo que combina elementos del modelo en cascada con la repetición de ciclos de desarrollo. Cada ciclo o "espiral" consta de cuatro fases: determinar objetivos, identificar y resolver riesgos, desarrollar y probar, y planificar la siguiente espiral. Este enfoque se centra en la gestión de riesgos y permite la adaptación a cambios.
### Metodologias Agiles:
#### Kanban
Es un enfoque ágil que se centra en la visualización del trabajo en un tablero Kanban. Las tareas se representan como tarjetas que se mueven a través de columnas, lo que permite a los equipos gestionar el flujo de trabajo de manera eficiente. Kanban se basa en la demanda y no tiene sprints fijos, lo que lo hace flexible para la gestión de tareas continuas.
#### Scrum
Es una de las metodologías ágiles más populares. Se basa en equipos autoorganizados que trabajan en ciclos llamados "sprints", generalmente de 2 a 4 semanas de duración. Scrum se enfoca en la colaboración, la comunicación regular y la entrega de incrementos de software funcionales al final de cada sprint.
#### Extreme Programming (XP)
Es una metodología ágil que se enfoca en la mejora continua de la calidad del software. Se basa en prácticas como la programación en parejas, pruebas unitarias frecuentes, entregas pequeñas y regulares, y una comunicación cercana con el cliente. XP promueve la adaptación a cambios y la entrega rápida de valor.

**Info: [Metodologias de un Proyecto de Software](https://blog.ganttpro.com/es/metodologia-proyecto/)**
## Arquitecturas de software
La arquitectura, referida al software, *es un concepto que surge ya en los años 60 y se refiere a una planificación basada en modelos, patrones y abstracciones teóricas, a la hora de realizar una pieza de software de cierta complejidad y como paso previo a cualquier implementación.* De esta forma se dispone de una guía teórica detallada que nos permite entender cómo van a encajar cada una de las piezas de nuestro producto o servicio.

Por tanto, en arquitectura llamamos patrón a cualquier solución general y reutilizable para problemas recurrentes en ingeniería del software en un contexto dado, son similares a los patrones usados en la programación, pero orientados específicamente a la estructura a un nivel superior y más genérico.
### Importancia de la arquitectura de software

La arquitectura nos permite planificar a priori nuestro desarrollo y elegir el mejor conjunto de herramientas para llevar a cabo nuestros proyectos, es por tanto un paso crítico antes siquiera de pasar a programar ya que determinará en gran medida el ritmo del desarrollo e incluso los factores económicos y humanos durante el proceso. Por tanto, a la hora de elegir un patrón de arquitectura siempre es necesario pensar en una serie de cuestiones que determinan el uso final que vamos a darle a nuestro software:

- **Coste -** ¿Cuánto estamos dispuestos a invertir en el desarrollo y mantenimiento de nuestro sistema? Como hemos visto hay ciertos patrones más complejos, que requieren más infraestructura y cuyo desarrollo puede ser más irregular, por tanto, hemos de saber cuánto estamos dispuestos a invertir primero en el desarrollo de nuestra aplicación.
- **Tiempo de desarrollo -** Igualmente, y muy relacionado con lo anterior, debemos de preguntarnos cuanto tiempo disponemos para desarrollar el producto, y cómo de cerca se encontraría la fecha de entrega o de salida al mercado.
- **Número de usuarios -** Sin duda uno de los ítems críticos a la hora de desarrollar el producto es preguntarnos qué tipo de producto es y cuantos usuarios soporta ¿Funciona a través de web? ¿Es stand-alone? ¿Debe de soportar cargas elevadas por diseño?, estas preguntas pueden declinarnos a elegir patrones más o menos distribuidos, pasando, por ejemplo, de uno menos distribuido como el de capas al más distribuido o broker.
- **Nivel de aislamiento -** Otro factor importante a tener en cuenta es si nuestro producto funciona de forma aislada al resto de productos del usuario o si debe de integrarse o permitir integraciones de terceros. Algunas arquitecturas, como la de capas, son más cerradas y podrían dificultar estas integraciones si lo escogemos sobre otras.

En ocasiones, y cuando tenemos estos hechos bien planteados y razonados, elegir un patrón de arquitectura también puede ser una cuestión de familiaridad, comodidad o simple preferencia, por eso es aconsejable probarlos, para intentar también familiarizarse con ellos y con el diferente flujo de trabajo que proponen.

- [Patrones de Arquitectura](https://openwebinars.net/blog/arquitectura-de-software-que-es-y-que-tipos-existen/)
---
## Patrones de diseño

**Los patrones de diseño son soluciones habituales a problemas que ocurren con frecuencia en el diseño de software. Son como planos prefabricados que se pueden personalizar para resolver un problema de diseño recurrente en tu código.**

No se puede elegir un patrón y copiarlo en el programa como si se tratara de funciones o bibliotecas ya preparadas. El patrón no es una porción específica de código, sino un concepto general para resolver un problema particular. Puedes seguir los detalles del patrón e implementar una solución que encaje con las realidades de tu propio programa.

A menudo los patrones se confunden con algoritmos porque ambos conceptos describen soluciones típicas a problemas conocidos. Mientras que un algoritmo siempre define un grupo claro de acciones para lograr un objetivo, un patrón es una descripción de más alto nivel de una solución. El código del mismo patrón aplicado a dos programas distintos puede ser diferente.

Una analogía de un algoritmo sería una receta de cocina: ambos cuentan con pasos claros para alcanzar una meta. Por su parte, un patrón es más similar a un plano, ya que puedes observar cómo son su resultado y sus funciones, pero el orden exacto de la implementación depende de ti.
### ¿En qué consiste el patrón?

La mayoría de los patrones se describe con mucha formalidad para que la gente pueda reproducirlos en muchos contextos. Aquí tienes las secciones que suelen estar presentes en la descripción de un patrón:

- El **propósito** del patrón explica brevemente el problema y la solución.
- La **motivación** explica en más detalle el problema y la solución que brinda el patrón.
- La **estructura** de las clases muestra cada una de las partes del patrón y el modo en que se relacionan.
- El **ejemplo de código** en uno de los lenguajes de programación populares facilita la asimilación de la idea que se esconde tras el patrón.

Algunos catálogos de patrones enumeran otros detalles útiles, como la aplicabilidad del patrón, los pasos de implementación y las relaciones con otros patrones.

[Todo Sobre Patrones de Diseño](https://refactoring.guru/es/design-patterns/what-is-patterna)
## 
---

